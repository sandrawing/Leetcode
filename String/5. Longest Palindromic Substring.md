https://leetcode.com/problems/longest-palindromic-substring/

Tips:
1. 判断一个字符串是否是回文字符串，比较简便的方法是s == s[::-1]

2. Python里判断一个String是否是另一个String的substring最简单的办法是 in 

Ex:

```ruby
>>> str = "Messi is the best soccer player"
>>> "soccer" in str
True
>>> "football" in str
False
```

3. find函数可以找到substring的开始的index

Ex:
```ruby
>>> str = "Messi is the best soccer player"
>>> str.find("soccer")
18
>>> str.find("Ronaldo")
-1
>>> str.find("Messi")
0
```


Original Code:
```ruby
class Solution:        
    def ispalindromic(self, s:str) -> bool:
        if s == s[::-1]:
            return True
        else:
            return False
        
    def longestPalindrome(self, s: str) -> str:
        if s == "" or self.ispalindromic(s):
            return s
        length = 1
        current_string = s[0]
        for i in range(len(s)):
            for j in range(i+1, len(s)):
                if s[i] != s[j - 1]:
                    continue
                elif self.ispalindromic(s[i:j]) and j-i > length:
                    length = j - i
                    current_string = s[i:j]
            if self.ispalindromic(s[i:]) and len(s)-i > length:
                length = len(s) - i
                current_string = s[i:]
        return current_string
```

Modified Methods: #1 Longest Common Substring

s 和 reverse(s) 共有的最长的 substring 就是longest palindromic substring -> 问题转成求Longest common substring problem

Longest common substring problem 在原来求Longest substring problem的基础上加上判断是否是reverse(s)的substring

这种解法可能存在一个问题，比如 S = "abacdfgdcaba", S′ = "abacdgfdcaba"，两者共有的最长的substring 是"abacd"，显然这个不是一个valid palindrome
可行的解决方法是 判断这两者的index，看看这两个index在原来的string里面是否是相同的

Original Code:
```ruby
class Solution:        
    def longestPalindrome(self, s: str) -> str:
        s_reverse = s[::-1]
        i, j, result = 0, 1, ""
        while i < len(s) and j <= len(s):
            substring = s[i:j]
            current_length = len(substring)
            begin_index = s_reverse.find(substring)
            if begin_index == -1:
                i += 1
            else:
                if len(substring) > len(result) and s_reverse[len(s)-j:len(s)-i] == substring:
                    result = substring
                j += 1
        return result
```

https://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Longest_common_substring#Python

网站上给出的找到Longest common substring的方法的基本思路：

用一个table（长度是len(s1)+1 乘上 len(s2)+1）记录各种可能情况的Common Substring的长度，遍历s1和s2中所有字符串，当两个字符串相同时，那么table[x][y]的值就应该是table[x-1][y-1]的值加1，当两个字符串不相同时，那么table[x][y]的数清零。其中longest记录的是最长字符串的长度，x_longest记录的是s1中substring的开始index。

```ruby
def longest_common_substring(s1, s2):
   m = [[0] * (1 + len(s2)) for i in range(1 + len(s1))]
   longest, x_longest = 0, 0
   for x in range(1, 1 + len(s1)):
       for y in range(1, 1 + len(s2)):
           if s1[x - 1] == s2[y - 1]:
               m[x][y] = m[x - 1][y - 1] + 1
               if m[x][y] > longest:
                   longest = m[x][y]
                   x_longest = x
           else:
               m[x][y] = 0
   return s1[x_longest - longest: x_longest]
```





