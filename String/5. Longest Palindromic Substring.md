https://leetcode.com/problems/longest-palindromic-substring/

Tips:
1. 判断一个字符串是否是回文字符串，比较简便的方法是s == s[::-1]

2. Python里判断一个String是否是另一个String的substring最简单的办法是 in  Ex:

>>> str = "Messi is the best soccer player"
>>> "soccer" in str
True
>>> "football" in str
False

Original Code:
```ruby
class Solution:        
    def ispalindromic(self, s:str) -> bool:
        if s == s[::-1]:
            return True
        else:
            return False
        
    def longestPalindrome(self, s: str) -> str:
        if s == "" or self.ispalindromic(s):
            return s
        length = 1
        current_string = s[0]
        for i in range(len(s)):
            for j in range(i+1, len(s)):
                if s[i] != s[j - 1]:
                    continue
                elif self.ispalindromic(s[i:j]) and j-i > length:
                    length = j - i
                    current_string = s[i:j]
            if self.ispalindromic(s[i:]) and len(s)-i > length:
                length = len(s) - i
                current_string = s[i:]
        return current_string
```

Modified Methods: #1 Longest Common Substring

s 和 reverse(s) 共有的最长的 substring 就是longest palindromic substring -> 问题转成求Longest common substring problem

Longest common substring problem 在原来求Longest substring problem的基础上加上判断是否是reverse(s)的substring

这种解法可能存在一个问题，比如 S = "abacdfgdcaba", S′ = "abacdgfdcaba"，两者共有的最长的substring 是"abacd"，显然这个不是一个valid palindrome
可行的解决方法是 判断这两者的index，看看这两个index在原来的string里面是否是相同的

```ruby


```





