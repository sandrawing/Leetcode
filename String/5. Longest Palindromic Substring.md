https://leetcode.com/problems/longest-palindromic-substring/

Tips:
1. 判断一个字符串是否是回文字符串，比较简便的方法是s == s[::-1]

2. Python里判断一个String是否是另一个String的substring最简单的办法是 in 

Ex:

```ruby
>>> str = "Messi is the best soccer player"
>>> "soccer" in str
True
>>> "football" in str
False
```

3. find函数可以找到substring的开始的index

Ex:
```ruby
>>> str = "Messi is the best soccer player"
>>> str.find("soccer")
18
>>> str.find("Ronaldo")
-1
>>> str.find("Messi")
0
```


Original Code:
```ruby
class Solution:        
    def ispalindromic(self, s:str) -> bool:
        if s == s[::-1]:
            return True
        else:
            return False
        
    def longestPalindrome(self, s: str) -> str:
        if s == "" or self.ispalindromic(s):
            return s
        length = 1
        current_string = s[0]
        for i in range(len(s)):
            for j in range(i+1, len(s)):
                if s[i] != s[j - 1]:
                    continue
                elif self.ispalindromic(s[i:j]) and j-i > length:
                    length = j - i
                    current_string = s[i:j]
            if self.ispalindromic(s[i:]) and len(s)-i > length:
                length = len(s) - i
                current_string = s[i:]
        return current_string
```

Modified Methods: #1 Longest Common Substring

s 和 reverse(s) 共有的最长的 substring 就是longest palindromic substring -> 问题转成求Longest common substring problem

Longest common substring problem 在原来求Longest substring problem的基础上加上判断是否是reverse(s)的substring

这种解法可能存在一个问题，比如 S = "abacdfgdcaba", S′ = "abacdgfdcaba"，两者共有的最长的substring 是"abacd"，显然这个不是一个valid palindrome
可行的解决方法是 判断这两者的index，看看这两个index在原来的string里面是否是相同的

Original Code:
```ruby
class Solution:        
    def longestPalindrome(self, s: str) -> str:
        s_reverse = s[::-1]
        i, j, result = 0, 1, ""
        while i < len(s) and j <= len(s):
            substring = s[i:j]
            current_length = len(substring)
            begin_index = s_reverse.find(substring)
            if begin_index == -1:
                i += 1
            else:
                if len(substring) > len(result) and s_reverse[len(s)-j:len(s)-i] == substring:
                    result = substring
                j += 1
        return result
```





