https://leetcode.com/problems/find-k-length-substrings-with-no-repeated-characters/

Given a string S, return the number of substrings of length K with no repeated characters.

My solution:

借鉴159题的思路写出来的

index_dict track的是每个现在的字符串出现的最新的一个index，保持index_dict的长度为k，那么下一次更新时候的start是现在所有dict里面values的最小值+1

```ruby
class Solution:
    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:
        if len(s) < 3:
            if k == 1 and len(s) == 2 and s[0] == s[1]:
                return 2
            return min(k, len(s))
        index_dict = {s[0]: 0}
        result = 1
        start = 0
        for end in range(len(s)):
            index_dict[s[end]] = end
            if len(index_dict) > k:
                del_idx = min(index_dict.values())
                del index_dict[s[del_idx]]
                start = del_idx + 1
            result = max(result, end - start + 1)
        
        return result
```

**错误方法**

```ruby
class Solution:
    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:
        if len(s) < 3:
            if k == 1 and len(s) == 2 and s[0] == s[1]:
                return 2
            return min(k, len(s))
        else:
            start = 0
            dis_num = 1
            index_map = {s[0]: 0}
            result = 1
            for end in range(1, len(s)):
                # 更新map的条件是是否出现连续相同的字符 如果一直都是cccc则不用更新 如果是ccac则a和c都要更新
                if s[end] != s[end - 1]:
                    index_map[s[end]] = end
                # track distinct number
                if s[end] not in s[start:end]:
                    dis_num += 1
                if dis_num <= k:
                    result = max(result, end - start + 1)
                else:
                    # 这个start的地方有误 在这种情况下很难找到距离现在有k个不一样的地方
                    # 之前k=2时候的代码 start = index_map[s[end - 1]] 因为k=2的时候 如果出现不一样 那么肯定保留下来的是出现这个不一样的点
                    # 和紧邻着这个不一样的点的之前的一个点 只要找到这个点从这个时候开始往前的最大不一样的地方就可以
                    # 但是k=3的时候直接往前推很难找到距离现在k个不一样的点的地方
                    start = index_map[s[start]] + 1
                    dis_num -= 1     
        return result
```

Solution from Educative.io

思路一样 更加麻烦

```ruby
class Solution:
    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:
        window_start = 0
        max_length = 0
        char_frequency = {}

        # in the following loop we'll try to extend the range [window_start, window_end]
        for window_end in range(len(s)):
            right_char = s[window_end]
            if right_char not in char_frequency:
                char_frequency[right_char] = 0
            char_frequency[right_char] += 1

            # shrink the sliding window, until we are left with 'k' distinct characters in the char_frequency
            while len(char_frequency) > k:
                left_char = s[window_start]
                char_frequency[left_char] -= 1
                if char_frequency[left_char] == 0:
                    del char_frequency[left_char]
                window_start += 1  # shrink the window
            # remember the maximum length so far
            max_length = max(max_length, window_end-window_start + 1)
        return max_length
  ```
