We can use a Two Pointers approach while iterating through the array. Letâ€™s say the two pointers are called low and high which are pointing to the first and the last element of the array respectively. So while iterating, we will move all 0s before low and all 2s after high so that in the end, all 1s will be between low and high.

```ruby
def dutch_flag_sort(arr):
  # all elements < low are 0, and all elements > high are 2
  # all elements from >= low < i are 1
  low, high = 0, len(arr) - 1
  i = 0
  while(i <= high):
    if arr[i] == 0:
      arr[i], arr[low] = arr[low], arr[i]
      # increment 'i' and 'low'
      i += 1
      low += 1
    elif arr[i] == 1:
      i += 1
    else:  # the case for arr[i] == 2
      arr[i], arr[high] = arr[high], arr[i]
      # decrement 'high' only, after the swap the number at index 'i' could be 0, 1 or 2
      high -= 1


def main():
  arr = [1, 0, 2, 1, 0]
  dutch_flag_sort(arr)
  print(arr)

  arr = [2, 2, 0, 1, 2, 0]
  dutch_flag_sort(arr)
  print(arr)


main()
```

Time complexity #
The time complexity of the above algorithm will be O(N) as we are iterating the input array only once.

Space complexity #
The algorithm runs in constant space O(1).

Algorithm

Initialise the rightmost boundary of zeros : p0 = 0. During the algorithm execution nums[idx < p0] = 0.

Initialise the leftmost boundary of twos : p2 = n - 1. During the algorithm execution nums[idx > p2] = 2.

Initialise the index of current element to consider : curr = 0.

While curr <= p2 :

If nums[curr] = 0 : swap currth and p0th elements and move both pointers to the right.

If nums[curr] = 2 : swap currth and p2th elements. Move pointer p2 to the left.

If nums[curr] = 1 : move pointer curr to the right.
