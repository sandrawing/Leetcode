Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.

My solution

```ruby
class Solution(object):
    def partition(self, arr, l, r):
        x = arr[r]
        i = l
        for j in range(l, r):
            if arr[j] <= x:
                arr[i], arr[j] = arr[j], arr[i]
                i += 1
        arr[i], arr[r] = arr[r], arr[i]
        return i
    
    def kLargest(self, arr, l, r, k):
        if k > 0 and k <= r-l+1:
            index = self.partition(arr, l, r)
            if k - 1 == index - l:
                return arr[index]
            if index - l > k -1:
                return self.kLargest(arr, l, index-1, k)
            return self.kLargest(arr, index+1, r, k-index+l-1)
    
    def findKthLargest(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        return self.kLargest(nums, 0, len(nums)-1, len(nums) - k + 1)
```

Time complexity : O(N) in the average case, O(N^2) in the worst case.
Space complexity : O(1).

Solution from Leetcode

Approach 1: Heap
The idea is to init a heap "the smallest element first", and add all elements from the array into this heap one by one keeping the size of the heap always less or equal to k. That would results in a heap containing k largest elements of the array.

The head of this heap is the answer, i.e. the kth largest element of the array.

The time complexity of adding an element in a heap of size k is O(logk), and we do it N times that means O(Nlogk) time complexity for the algorithm.

In Python there is a method nlargest in heapq library which has the same O(Nlogk) time complexity and reduces the code to one line.

```ruby
class Solution(object):  
    def findKthLargest(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        return heapq.nlargest(k, nums)[-1]
```

Time complexity : O(Nlogk).
Space complexity : O(k) to store the heap elements.
